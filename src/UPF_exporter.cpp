#include "UPF_exporter.h"
#include "utility.h"

void IPTables_Exporter::
    upf_export(const std::vector<std::unique_ptr<UPF_Ruleset>>& rulesets,
               const std::string filepath,
               bool, bool enable_log) const{

    // Exporter for ClassBench rulesets
    using namespace Utility;

    std::stringstream stream;
    std::string new_iptables_rule;
    stream << "# Generated by UPF_Exporter" << std::endl;
    stream << "*filter" << std::endl;
    stream << ":FORWARD ACCEPT [0:0]" << std::endl;
//    "*filter" << std::endl << ":INPUT DROP [0:0]" << std::endl <<
//    ":FORWARD ACCEPT [0:0]" << std::endl << ":OUTPUT ACCEPT [0:0]" <<
//    std::endl;
    for (unsigned int i = 0; i < rulesets.size(); ++i){
        stream << ":" << rulesets[i]->get_name() << " - [0:0]" << std::endl;
    }
    stream << "-A FORWARD -p tcp --sport 22 -j ACCEPT" << std::endl;
    stream << "-A FORWARD -p tcp --dport 22 -j ACCEPT" << std::endl;
    stream << "-A FORWARD -j " << rulesets[0]->get_name() << std::endl;
     for (unsigned int k = 0; k < rulesets.size(); ++k){
      UPF_Ruleset* ruleset = rulesets[k].get();
      for (unsigned int i = 0; i < ruleset->size(); ++i){
      const UPF_Rule& current_rule = ruleset->get_rule(i);
      // if Freerule then build IPTables rule
      if(current_rule.get_type() == freerule){
          if(current_rule.get_original_rule() == "UPF_RULE"){
            stream << "-A " << ruleset->get_name() << " ";
            ProtocolType l4p = TRANSPORT;
            if(current_rule.get_field(interface_in_field) != nullptr){
              Range iface_in = current_rule.get_field(interface_in_field)
                               ->get_range();
              stream << "-i " << range_to_interface(iface_in) << " ";
              }
            if(current_rule.get_field(interface_out_field) != nullptr){
              Range iface_out = current_rule.get_field(interface_in_field)
                                ->get_range();
              stream << "-o " << range_to_interface(iface_out) << " ";
            }
            if(current_rule.get_field(l4_proto) != nullptr){
              Range l4_prt = current_rule.get_field(l4_proto)->get_range();
              if(!l4_prt.is_wildcard() && is_valid_protocol_range(l4_prt)){
                stream << "-p " << range_to_l4_protocol(l4_prt) << " ";
                if (l4_prt.lower_.get_low() == 6)
                  l4p = TCP;
                else if(l4_prt.lower_.get_low() == 17)
                  l4p = UDP;
                else if(l4_prt.lower_.get_low() == 1)
                  l4p = ICMP;
              }
            }
            if(current_rule.get_field(l3_src) != nullptr){
              Range l3_s = current_rule.get_field(l3_src)->get_range();
              if(!range_to_ipv4_range_cidr(l3_s).empty())
                stream << "-s " << range_to_ipv4_range_cidr(l3_s) << " ";
              else if (!l3_s.is_wildcard()){
                stream << "-m iprange --src-range " <<
              range_to_ipv4_range_score(l3_s) << " ";
              }
            }
          if(current_rule.get_field(l3_dst) != nullptr){
            Range l3_d = current_rule.get_field(l3_dst)->get_range();
            if(!range_to_ipv4_range_cidr(l3_d).empty())
              stream << "-d " << range_to_ipv4_range_cidr(l3_d) << " ";
            else if(!l3_d.is_wildcard()){
              stream << "-m iprange --dst-range " <<
              range_to_ipv4_range_score(l3_d) << " ";
            }
          }
          if(current_rule.get_field(l4_src) != nullptr){
            Range l4_s = current_rule.get_field(l4_src)->get_range();
            Range l4_prt = current_rule.get_field(l4_proto)->get_range();
            if((l4p == TCP || l4p == UDP) && !l4_s.is_wildcard())
              stream << "--sport " << range_to_port_colon(l4_s) << " ";
            else if (l4p == ICMP && !l4_s.is_wildcard())
              stream << "--icmp-type " << range_to_icmptype(l4_s) << " ";
          }
          if(current_rule.get_field(l4_dst) != nullptr){
            Range l4_d = current_rule.get_field(l4_dst)->get_range();
            Range l4_prt = current_rule.get_field(l4_proto)->get_range();
            if((l4p == TCP || l4p == UDP) && !l4_d.is_wildcard())
              stream << "--dport " << range_to_port_colon(l4_d) << " ";
//          else if (l4p == ICMP && !l4_d.is_wildcard())
////            stream << "--icmp-code " << range_to_icmptype(l4_d) << " ";
          }
          if(enable_log)
            stream << "-j LOG " << std::endl;
          else{
            if(current_rule.get_action().get_type() == ACCEPT)
              stream << "-j ACCEPT " << std::endl;
            else if(current_rule.get_action().get_type() == BLOCK)
              stream << "-j DROP " << std::endl;
            else if(current_rule.get_action().get_type() == JUMP)
                        stream << "-j " << current_rule.get_action().get_target()
                        << std::endl;
          }
          }
          else
            stream << "-A " << ruleset->get_name() << " " << current_rule.get_original_rule() << std::endl;
        }
        else{
            // Print Legacy Rules
            stream <<  "-A " << ruleset->get_name() << " " << current_rule.get_original_rule() << std::endl;
        }

      }
    }
    stream << "COMMIT" << std::endl;
    std::ofstream write;
    std::remove(filepath.c_str());
    write.open(filepath);
    write << stream.str();
    write.close();
}

//static bool find_ruleset(UPF_Ruleset* ruleset,
//                         std::string target){
//  return (ruleset->get_name() == target);
//}


void ipfw_Exporter::upf_export(
    const std::vector<std::unique_ptr<UPF_Ruleset>>& rulesets,
    const std::string filepath, bool cross_translate,
    bool enable_log) const{


    std::vector<unsigned int> jump_positions;

    //Count Rule positions for jumps
//    jump_positions.push_back(1);
    unsigned int offset = 3;
    for(unsigned int k = 0; k < rulesets.size(); ++k){
      offset += rulesets[k]->size();
      jump_positions.push_back(offset);
    }
    using namespace Utility;

    std::stringstream stream;
    stream << "# Generated by UPF_Exporter" << std::endl;
    stream << "ipfw -q -f flush" << std::endl;
    stream << "ipfw table all flush" << std::endl;
    stream << "# Rules to add" << std::endl;
    stream << "ipfw -q add 1 allow all from any 22 to any" << std::endl;
    stream << "ipfw -q add 2 allow all from any to any 22" << std::endl;
    unsigned int rule_count = 2;
    int table_count_src = -1;
    int table_count_dst = 0;
    for (unsigned int k = 0; k < rulesets.size(); ++k){
      UPF_Ruleset* ruleset = rulesets[k].get();
      for (unsigned int i = 0; i < ruleset->size(); ++i){
        ++rule_count;
//        std::cout << i << std::endl;
//        std::string rule_number = zeropad(rule_count);
        // if Freerule then build ipfw rule
        const UPF_Rule& current_rule  = ruleset->get_rule(i);
        if(ruleset->get_rule(i).get_type() == freerule && !cross_translate){
//          if(current_rule.get_original_rule() == "UPF_RULE"){
            if(current_rule.get_field(l3_src) != nullptr){
                const Range& rng = current_rule.get_field(l3_src)->get_range();
                if(range_to_ipv4_range_cidr(rng).empty() && !rng.is_wildcard()){
                  table_count_src += 2;
                  std::vector<CIDR> cidr_list = ipv4_range_to_cidr_list(rng);
                  for (unsigned int i = 0; i < cidr_list.size(); ++i){
                    const CIDR& current = cidr_list[i];
                    stream << "ipfw table " << table_count_src << " add " <<
                    int_to_ipv4(current.addr_) << "/" << current.mask_ << std::endl;
                  }
                }
              }
              if(current_rule.get_field(l3_dst) != nullptr){
                const Range& rng = current_rule.get_field(l3_dst)->get_range();
                if(range_to_ipv4_range_cidr(rng).empty() && !rng.is_wildcard()){
                  table_count_dst += 2;
                  std::vector<CIDR> cidr_list = ipv4_range_to_cidr_list(rng);
                  for (unsigned int i = 0; i < cidr_list.size(); ++i){
                    const CIDR& current = cidr_list[i];
                    stream << "ipfw table " << table_count_dst << " add " <<
                    int_to_ipv4(current.addr_) << "/" << current.mask_ << std::endl;
                  }
                }
              }
              stream << "ipfw -q add " << rule_count;
              if(current_rule.get_action().get_type() == ACCEPT)
                stream << " allow ";
              else if (current_rule.get_action().get_type() == BLOCK)
                stream << " deny ";
              else if(current_rule.get_action().get_type() == JUMP){
                std::string target = current_rule.get_action().get_target();
                auto iter = std::find_if(rulesets.begin(), rulesets.end(),
                      [target] (const std::unique_ptr<UPF_Ruleset>& a)-> bool{
                      return (a->get_name() == target);});
                auto position = iter - rulesets.begin();
                stream << " skipto " << jump_positions[position-1] << " ";
              }
              if(enable_log)
                stream << "log ";

              ProtocolType l4p = TRANSPORT;
              if(current_rule.get_field(l4_proto) != nullptr){
                Range l4_prt = current_rule.get_field(l4_proto)->get_range();
                  if(l4_prt.lower_.get_low() != 0){
                    stream << range_to_l4_protocol(l4_prt) << " ";
                    if (l4_prt.lower_.get_low() == 6)
                      l4p = TCP;
                        else if(l4_prt.lower_.get_low() == 17)
                          l4p = UDP;
                  }
                  else
                    stream << "all ";
                }
                if(current_rule.get_field(l3_src) != nullptr){
                    Range l3_s = current_rule.get_field(l3_src)->get_range();
                    if(!range_to_ipv4_range_cidr(l3_s).empty())
                      stream << "from " << range_to_ipv4_range_cidr(l3_s) << " ";
                    else if(!l3_s.is_wildcard())
                      stream << "from " << "\"table(" << table_count_src << ")\" ";
                    else
                      stream << "from any ";
                }
                else
                    stream << "from any ";
                if(current_rule.get_field(l4_src) != nullptr){
                    Range l4_s = current_rule.get_field(l4_src)->get_range();
                    Range l4_prt = current_rule.get_field(l4_proto)->get_range();
                    if((l4p == TCP || l4p == UDP) && !l4_s.is_wildcard()){
                        stream << range_to_port_score(l4_s) << " ";
                    }
                    else if (l4p == ICMP){
                        stream << "icmptypes" << range_to_icmptype(l4_s) << " ";
                    }
                }
                if(current_rule.get_field(l3_dst) != nullptr){
                    Range l3_d = current_rule.get_field(l3_dst)->get_range();
                    if(!range_to_ipv4_range_cidr(l3_d).empty())
                      stream << "to " << range_to_ipv4_range_cidr(l3_d) << " ";
                    else if(!l3_d.is_wildcard())
                      stream << "to " << "\"table(" << table_count_dst << ")\" ";
                    else
                      stream << "to any ";
                }
                else
                    stream << "to any ";
                if(current_rule.get_field(l4_dst) != nullptr){
                    Range l4_d = current_rule.get_field(l4_dst)->get_range();
                    Range l4_prt = current_rule.get_field(l4_proto)->get_range();
                     if((l4p == TCP || l4p == UDP) && !l4_d.is_wildcard()){
                        stream << range_to_port_score(l4_d) << " ";
                    }
//                    else if (l4p == ICMP){
//                        stream << "icmptypes" << range_to_icmptype(l4_d) << " ";
//                    }
                }
                if(current_rule.get_field(interface_in_field) != nullptr){
                    Range iface_in = current_rule.get_field(interface_in_field)
                                     ->get_range();
                    stream << "in via " << range_to_interface(iface_in) << " ";
                }
                if(current_rule.get_field(interface_out_field) != nullptr){
                    Range iface_out = current_rule.get_field(interface_in_field)
                                     ->get_range();
                    stream << "out via " << range_to_interface(iface_out) << " ";
                }
                    stream << std::endl;
//          }
//          else
//            stream << current_rule.get_original_rule() << std::endl;
        }
      else
        stream << current_rule.get_original_rule() << std::endl;
      }
  }
  std::ofstream write;
  std::remove(filepath.c_str());
  write.open(filepath);
  write << stream.str();
  write.close();
}

void pf_Exporter::
        upf_export(const std::vector<std::unique_ptr<UPF_Ruleset>>& rulesets,
                   const std::string filepath,
                   bool cross_translate,
                   bool enable_log) const{


    // Simple Exporter for ClassBench rulesets

    using namespace Utility;

    std::stringstream stream;
    std::stringstream tables;
    tables << "# Generated by UPF_Exporter" << std::endl <<
    "# Rules to add" << std::endl;
    stream << "pass in quick proto tcp from any port 22 to any"  << std::endl;
    stream << "pass in quick proto tcp from any to any port 22"  << std::endl;
    if(rulesets.size() > 1){
      stream << "anchor " << rulesets[0]->get_name() <<
      " in quick all " << std::endl;
    }
    for (unsigned int k = 0; k < rulesets.size(); ++k){
        UPF_Ruleset* ruleset = rulesets[k].get();
        if(rulesets.size() > 1){
          stream << "anchor " << "\"" << ruleset->get_name() << "\" {" << std::endl;
        }
        for (unsigned int i = 0; i < ruleset->size(); ++i){
          const UPF_Rule& current_rule  = ruleset->get_rule(i);
          if(ruleset->get_rule(i).get_type() == freerule && !cross_translate){
            if(current_rule.get_original_rule() == "UPF_RULE"){
            // if Freerule then build pf rule
              if(current_rule.get_action().get_type() == ACCEPT)
                  stream << "pass in quick ";
                else if (current_rule.get_action().get_type() == BLOCK)
                  stream << "block in quick ";
                else if (current_rule.get_action().get_type() == JUMP)
                  stream << "anchor " << current_rule.get_action().get_target()
                  << " in quick ";
                if(enable_log)
                  stream << "log ";
                ProtocolType l4p = TRANSPORT;
                if(current_rule.get_field(interface_in_field) != nullptr){
                        Range iface_in = current_rule.get_field(interface_in_field)
                                         ->get_range();
                        stream << "on " << range_to_interface(iface_in) << " ";
                    }
                    if(current_rule.get_field(interface_out_field) != nullptr){
                        Range iface_out = current_rule.get_field(interface_in_field)
                                         ->get_range();
                        stream << "on " << range_to_interface(iface_out) << " ";
                    }
                    if(current_rule.get_field(l4_proto) != nullptr){
                        Range l4_prt = current_rule.get_field(l4_proto)->get_range();
                        if(l4_prt.lower_.get_low() != 0){
                            stream << "proto " << range_to_l4_protocol(l4_prt) << " ";
                            if (l4_prt.lower_.get_low() == 6)
                                l4p = TCP;
                            else if(l4_prt.lower_.get_low() == 17)
                                l4p = UDP;
                        }
                    }
                    if(current_rule.get_field(l3_src) != nullptr){
                        const Range& l3_s = current_rule.get_field(l3_src)->get_range();
                        if(!range_to_ipv4_range_cidr(l3_s).empty())
                          stream << "from " << range_to_ipv4_range_cidr(l3_s) << " ";
                        else if (!l3_s.is_wildcard())
                          stream << "from hash/" << range_to_ipv4_range_score(l3_s) <<" ";
                        else
                          stream << "from any ";
                    }
                    else
                      stream << "from any ";
                    if(current_rule.get_field(l4_src) != nullptr){
                        const Range& l4_s = current_rule.get_field(l4_src)->get_range();
    //                    const Range& l4_prt = current_rule.get_field(l4_proto)->get_range();
                        if(l4p == TCP || l4p == UDP){
                            stream << "port " << range_to_port_colon(l4_s) << " ";
                        }
                    }
                    if(current_rule.get_field(l3_dst) != nullptr){
                        Range l3_d = current_rule.get_field(l3_dst)->get_range();
                        if(!range_to_ipv4_range_cidr(l3_d).empty())
                            stream << "to " << range_to_ipv4_range_cidr(l3_d) << " ";
                        else if(!l3_d.is_wildcard())
                            stream << "to " << range_to_ipv4_range_score(l3_d) <<" ";
                        else
                          stream << "to any ";
                    }
                    else
                        stream << "to any ";
                    if(current_rule.get_field(l4_dst) != nullptr){
                        Range l4_d = current_rule.get_field(l4_dst)->get_range();
                        Range l4_prt = current_rule.get_field(l4_proto)->get_range();
                         if(l4p == TCP || l4p == UDP){
                            stream << "port " << range_to_port_colon(l4_d);
                        }
                        else if (l4p == ICMP){
                            stream << "icmp-type " << range_to_icmptype(l4_d) << " ";
                            if(current_rule.get_field(l4_src) != nullptr){
                               Range l4_s = current_rule.get_field(l4_src)->get_range();
//                               stream << "icmp-type-code " << range_to_icmptype(l4_s);
                               }
                        }
                    }
                  stream << std::endl;
            }
            else
              stream << current_rule.get_original_rule() << std::endl;
          }
          else
            stream << current_rule.get_original_rule() << std::endl;
        }
        if(rulesets.size() > 1)
          stream << "}" << std::endl;
    }

    std::ofstream write;
    std::remove(filepath.c_str());
    write.open(filepath);
    write << tables.str();
    write << stream.str();
    write.close();
}

void ipf_Exporter::
        upf_export(const std::vector<std::unique_ptr<UPF_Ruleset>>& rulesets,
                   const std::string filepath,
                   bool cross_translate,
                   bool enable_log) const{

    std::vector<unsigned int> jump_positions;
    using namespace Utility;
    //Count Rule positions for jumps
    unsigned int offset = 2;
    for(unsigned int k = 0; k < rulesets.size(); ++k){
      offset += rulesets[k]->size();
      jump_positions.push_back(offset);
    }
    // Create Ip Pools
    std::stringstream stream;
    std::stringstream ippool_stream;
    ippool_stream << "# Generated by UPF_Exporter" << std::endl;
    ippool_stream << "# Create IP Pools" << std::endl;
    ippool_stream << "ippool -F" << std::endl;
    ippool_stream << "ippool -f - << EOF" << std::endl;
    int table_count_src = -1;
    int table_count_dst = 0;
    stream << "# Rules to add" << std::endl;
    stream << "/sbin/ipf -Fa -f - << EOF" << std::endl;
    stream << "pass in quick proto tcp from any port = 22 to any comment \"1\""  << std::endl;
    stream << "pass in quick proto tcp from any to any port = 22 comment \"2\"" << std::endl;
    unsigned int rule_count = 2;
    for (unsigned int k = 0; k < rulesets.size(); ++k){
      UPF_Ruleset* ruleset = rulesets[k].get();
      for (unsigned int i = 0; i < ruleset->size(); ++i){
        ++rule_count;
        const UPF_Rule& current_rule  = ruleset->get_rule(i);
          if(ruleset->get_rule(i).get_type() == freerule && !cross_translate){
            if(current_rule.get_original_rule() == "UPF_RULE"){
            // if Freerule then build pf rule
            if(current_rule.get_field(l3_src) != nullptr){
          const Range& rng = current_rule.get_field(l3_src)->get_range();
          if(range_to_ipv4_range_cidr(rng).empty() && !rng.is_wildcard()){
            table_count_src += 2;
            ippool_stream << "pool ipf/hash (name \"" << table_count_src << "\";)"
            << std::endl << "{";
            std::vector<CIDR> cidr_list = ipv4_range_to_cidr_list(rng);
            for (unsigned int i = 0; i < cidr_list.size(); ++i){
              const CIDR& current = cidr_list[i];
              ippool_stream << int_to_ipv4(current.addr_) << "/" << current.mask_ << ";"
              << std::endl;
            }
            ippool_stream << "};" << std::endl;
          }
        }
        if(current_rule.get_field(l3_dst) != nullptr){
          const Range& rng = current_rule.get_field(l3_dst)->get_range();
          if(range_to_ipv4_range_cidr(rng).empty() && !rng.is_wildcard()){
            table_count_dst += 2;
                       ippool_stream << "pool ipf/hash (name \"" << table_count_dst << "\";)"
            << std::endl << "{";
            std::vector<CIDR> cidr_list = ipv4_range_to_cidr_list(rng);
            for (unsigned int i = 0; i < cidr_list.size(); ++i){
              const CIDR& current = cidr_list[i];
              ippool_stream << int_to_ipv4(current.addr_) << "/" << current.mask_ << ";"
              << std::endl;
            }
            ippool_stream << "};" << std::endl;
          }
        }
              if(current_rule.get_action().get_type() == ACCEPT)
                  stream << "pass in quick ";
                else if (current_rule.get_action().get_type() == BLOCK)
                  stream << "block in quick ";
                else if (current_rule.get_action().get_type() == JUMP){
                  std::string target = current_rule.get_action().get_target();
                  auto iter = std::find_if(rulesets.begin(), rulesets.end(),
                      [target] (const std::unique_ptr<UPF_Ruleset>& a)-> bool{
                      return (a->get_name() == target);});
                  auto position = iter - rulesets.begin();
                  stream << "skip " << jump_positions[position-1]-rule_count
                    <<  " in quick ";
                }
                if (enable_log)
                  stream << "log ";
                ProtocolType l4p = TRANSPORT;
                if(current_rule.get_field(interface_in_field) != nullptr){
                        Range iface_in = current_rule.get_field(interface_in_field)
                                         ->get_range();
                        stream << "on " << range_to_interface(iface_in) << " ";
                    }
                    if(current_rule.get_field(interface_out_field) != nullptr){
                        Range iface_out = current_rule.get_field(interface_in_field)
                                         ->get_range();
                        stream << "on " << range_to_interface(iface_out) << " ";
                    }
                    if(current_rule.get_field(l4_proto) != nullptr){
                        Range l4_prt = current_rule.get_field(l4_proto)->get_range();
                        if(l4_prt.lower_.get_low() != 0){
                            stream << "proto " << range_to_l4_protocol(l4_prt) << " ";
                            if (l4_prt.lower_.get_low() == 6)
                                l4p = TCP;
                            else if(l4_prt.lower_.get_low() == 17)
                                l4p = UDP;
                        }
                    }
                    if(current_rule.get_field(l3_src) != nullptr){
                        const Range& l3_s = current_rule.get_field(l3_src)->get_range();
                        if(!range_to_ipv4_range_cidr(l3_s).empty())
                          stream << "from " << range_to_ipv4_range_cidr(l3_s) << " ";
                        else if (!l3_s.is_wildcard())
                          stream << "from hash/" << table_count_src <<" ";
                        else
                          stream << "from any ";
                    }
                    else
                      stream << "from any ";
                    if(current_rule.get_field(l4_src) != nullptr){
                        const Range& l4_s = current_rule.get_field(l4_src)->get_range();
    //                    const Range& l4_prt = current_rule.get_field(l4_proto)->get_range();
                        if(l4p == TCP || l4p == UDP){
                            if(l4_s.lower_ == l4_s.upper_)
                              stream << "port = " << range_to_port_colon(l4_s) << " ";
                            else
                              stream << "port " << range_to_port_colon(l4_s) << " ";
                        }
                    }
                    if(current_rule.get_field(l3_dst) != nullptr){
                        Range l3_d = current_rule.get_field(l3_dst)->get_range();
                        if(!range_to_ipv4_range_cidr(l3_d).empty())
                            stream << "to " << range_to_ipv4_range_cidr(l3_d) << " ";
                        else if(!l3_d.is_wildcard())
                            stream << "to hash/" << table_count_dst <<" ";
                        else
                          stream << "to any ";
                    }
                    else
                        stream << "to any ";
                    if(current_rule.get_field(l4_dst) != nullptr){
                        Range l4_d = current_rule.get_field(l4_dst)->get_range();
                        Range l4_prt = current_rule.get_field(l4_proto)->get_range();
                         if(l4p == TCP || l4p == UDP){
                            if(l4_d.lower_ == l4_d.upper_)
                              stream << "port = " << range_to_port_colon(l4_d) << " ";
                            else
                              stream << "port " << range_to_port_colon(l4_d) << " ";
                        }
                        else if (l4p == ICMP){
                            stream << "icmp-type " << range_to_icmptype(l4_d) << " ";
                            if(current_rule.get_field(l4_src) != nullptr){
                               Range l4_s = current_rule.get_field(l4_src)->get_range();
//                               stream << "icmp-type-code " << range_to_icmptype(l4_s);
                               }
                        }
                    }
                  stream << "comment \"" << rule_count << "\"" << std::endl;
            }
            else
              stream << current_rule.get_original_rule() <<
              "comment \"" << rule_count << std::endl;
          }
          else
            stream << current_rule.get_original_rule() <<
            "comment \"" << rule_count << std::endl;
      }
      }
  ippool_stream << "EOF" << std::endl;
  stream << "EOF" << std::endl;
  ippool_stream << stream.str();
  std::ofstream write;
  std::remove(filepath.c_str());
  write.open(filepath);
  write << ippool_stream.str();
  write.close();
}


std::ostream& operator<<(std::ostream& out, const UPF_Ruleset& rset){
  return rset.print(out);
}
